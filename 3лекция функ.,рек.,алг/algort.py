# Алгоритмы
# Алгоритмом называется набор инструкций для выполнения некоторой задачи. Впринципе, любой фрагмент программного кода можно назвать алгоритмом, но мы с
# Вами рассмотрим 2 самых интересных алгоритмы сортировок:
# ● Быстрая сортировка
# ● Сортировка слиянием
# Быстрая сортировка
# “Программирование это разбиение чего-то большого и невозможного на что-томаленькое и вполне реальное”
# Быстрая сортировка принадлежит такой стратегии, как “разделяй и властвуй”.
# Сначала рассмотрим пример, затем напишем программный код
# Два друга решили поиграть в игру: один загадывает число от 1 до 100, другойдолжен отгадать. Согласитесь, что мы можем перебирать эти значения в случайном порядке, например: 32, 27, 60, 73… Да, мы можем угадать в какой-то момент, но что если мы обратиться к стратегии “разделяй и властвуй” Обозначим друзей, друг_1 это Иван, который загадал число, друг_2 это Петр, который отгадывает. Итак
# начнем:
# Иван загадал число 77.
# Петр: Число больше 50? Иван: Да.
# Петр: Число больше 75? Иван: Да.
# Петр: Число больше 87? Иван: Нет.
# Петр: Число больше 81? Иван: Нет.
# Петр: Число больше 78? Иван: Нет.
# Петр: Число больше 76? Иван: Да
# Число оказалось в диапазоне 76 < x < 78, значит это число 77. Задача решена. На самом деле мы сейчас познакомились с алгоритмом бинарного поиска, который также принадлежит стратегии “разделяй и властвуй”. Давайте перейдем к обсуждению программного кода быстрой сортировки.
def quicksort(array): #задаем функцию, параметром будет массив array
    if len(array) < 2:   #задаем базис
       return array
    else:
     pivot = array[0] # создаем переменную, где будет хранится наш первый элемент
    less = [i for i in array[1:] if i <= pivot] # находим первый массив,куда будем добавлят все элементы, следующие за 1 (1:) и которые <= переменной pivot
    greater = [i for i in array[1:] if i > pivot]# находим второй массив,куда будем добавлят все элементы, следующие за 1 (1:) и которые > переменной pivot
    return quicksort(less) + [pivot] + quicksort(greater)# вызываем рекурсию, сортируем каждую функцию , добавляем имquicksort, тт.к. pivot не список, преобразуем его в список ,обрамляем []
print(quicksort([10, 5, 2, 3]))# вызываем функцию

# ● 1-е повторение рекурсии:
# ○ array = [10, 5, 2, 3]
# ○ pivot = 10
# ○ less = [5, 2, 3]
# ○ greater = []
# ○ return quicksort([5, 2, 3]) + [10] + quicksort([])
# ● 2-е повторение рекурсии:
# ○ array = [5, 2, 3]
# ○ pivot = 5
# ○ less = [2, 3]
# ○ greater = []
# ○ return quicksort([2, 3]) + [5] + quicksort([]) # Важно! Не забывайте, что
# здесь помимо вызова рекурсии добавляется список [10]
# ● 3-е повторение рекурсии:
# ○ array = [2, 3]
# ○ return [2, 3] # Сработал базовый случай рекурсии
# На этом работа рекурсии завершилась и итоговый список будет выглядеть таким
# образом: [2, 3] + [5] + [10] = [2, 3, 5, 10]